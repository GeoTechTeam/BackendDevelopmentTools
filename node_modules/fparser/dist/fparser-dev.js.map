{"version":3,"file":"fparser-dev.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACA,IAAMA,cAAc,GAAG;IACnBC,EAAE,EAAEC,IAAI,CAACD,EAAE;IACXE,CAAC,EAAED,IAAI,CAACC,CAAC;IACTC,GAAG,EAAEF,IAAI,CAACE,GAAG;IACbC,IAAI,EAAEH,IAAI,CAACG,IAAI;IACfC,KAAK,EAAEJ,IAAI,CAACI,KAAK;IACjBC,MAAM,EAAEL,IAAI,CAACK,MAAM;IACnBC,OAAO,EAAEN,IAAI,CAACM,OAAO;IACrBC,KAAK,EAAEP,IAAI,CAACO;EAChB,CAAC;EAAC,IACmBC,OAAO,GAAAC,QAAA,CAAAC,OAAA;IACxB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,SAAAF,QAAYG,IAAI,EAAgB;MAAA,IAAdC,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;MAAAG,eAAA,OAAAR,OAAA;MAC1B,IAAI,CAACS,iBAAiB,GAAG,IAAI;MAC7B,IAAI,CAACL,OAAO,GAAAM,aAAA,CAAAA,aAAA,KAAO;QAACC,WAAW,EAAE;MAAK,CAAC,GAAKP,OAAO,CAAC;MACpD,IAAI,CAACQ,UAAU,GAAG,EAAE;MACpB,IAAI,CAACC,OAAO,GAAG,CAAC,CAAC;MACjB,IAAI,CAACC,UAAU,CAACX,IAAI,CAAC;IACzB;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;IANIY,YAAA,CAAAf,OAAA;MAAAgB,GAAA;MAAAC,KAAA,EAOA,SAAAH,WAAWI,aAAa,EAAE;QACtB,IAAIA,aAAa,EAAE;UACf,IAAI,CAACT,iBAAiB,GAAG,IAAI;UAC7B,IAAI,CAACG,UAAU,GAAG,EAAE;UACpB,IAAI,CAACC,OAAO,GAAG,CAAC,CAAC;UACjB,IAAI,CAACM,UAAU,GAAGD,aAAa;UAC/B,IAAI,CAACT,iBAAiB,GAAG,IAAI,CAACW,KAAK,CAACF,aAAa,CAAC;QACtD;QACA,OAAO,IAAI;MACf;;MAEA;AACJ;AACA;AACA;IAHI;MAAAF,GAAA;MAAAC,KAAA,EAIA,SAAAI,kBAAA,EAAoB;QAChB,IAAI,CAACjB,OAAO,CAACO,WAAW,GAAG,IAAI;MACnC;;MAEA;AACJ;AACA;IAFI;MAAAK,GAAA;MAAAC,KAAA,EAGA,SAAAK,mBAAA,EAAqB;QACjB,IAAI,CAAClB,OAAO,CAACO,WAAW,GAAG,KAAK;QAChC,IAAI,CAACE,OAAO,GAAG,CAAC,CAAC;MACrB;;MAEA;AACJ;AACA;AACA;AACA;IAJI;MAAAG,GAAA;MAAAC,KAAA,EAKA,SAAAM,oBAAoBC,OAAO,EAAE;QACzB;QACA,IAAIC,MAAM,GAAG,CAAC;UACVC,QAAQ,GAAG,EAAE;QACjB,IAAMC,MAAM,GAAG,EAAE;QAAC,IAAAC,SAAA,GAAAC,0BAAA,CACFL,OAAO,CAACM,KAAK,CAAC,EAAE,CAAC;UAAAC,KAAA;QAAA;UAAjC,KAAAH,SAAA,CAAAI,CAAA,MAAAD,KAAA,GAAAH,SAAA,CAAAK,CAAA,IAAAC,IAAA,GAAmC;YAAA,IAA1BC,GAAG,GAAAJ,KAAA,CAAAd,KAAA;YACR,IAAIkB,GAAG,KAAK,GAAG,IAAIV,MAAM,KAAK,CAAC,EAAE;cAC7B;cACAE,MAAM,CAACS,IAAI,CAACV,QAAQ,CAAC;cACrBA,QAAQ,GAAG,EAAE;YACjB,CAAC,MAAM,IAAIS,GAAG,KAAK,GAAG,EAAE;cACpBV,MAAM,EAAE;cACRC,QAAQ,IAAIS,GAAG;YACnB,CAAC,MAAM,IAAIA,GAAG,KAAK,GAAG,EAAE;cACpBV,MAAM,EAAE;cACRC,QAAQ,IAAIS,GAAG;cACf,IAAIV,MAAM,GAAG,CAAC,EAAE;gBACZ,MAAM,IAAIY,KAAK,CAAC,sCAAsC,CAAC;cAC3D;YACJ,CAAC,MAAM;cACHX,QAAQ,IAAIS,GAAG;YACnB;UACJ;QAAC,SAAAG,GAAA;UAAAV,SAAA,CAAAW,CAAA,CAAAD,GAAA;QAAA;UAAAV,SAAA,CAAAY,CAAA;QAAA;QACD,IAAIf,MAAM,KAAK,CAAC,EAAE;UACd,MAAM,IAAIY,KAAK,CAAC,sCAAsC,CAAC;QAC3D;QACA,IAAIX,QAAQ,CAACpB,MAAM,GAAG,CAAC,EAAE;UACrBqB,MAAM,CAACS,IAAI,CAACV,QAAQ,CAAC;QACzB;QACA,OAAOC,MAAM;MACjB;;MAEA;AACJ;AACA;AACA;IAHI;MAAAX,GAAA;MAAAC,KAAA,EAIA,SAAAwB,mBAAmBT,CAAC,EAAE;QAClBA,CAAC,GAAGA,CAAC,CAACU,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC;QACzB;QACAC,MAAM,CAACC,IAAI,CAACtD,cAAc,CAAC,CAACuD,OAAO,CAAC,UAACC,CAAC,EAAK;UACvCd,CAAC,GAAGA,CAAC,CAACU,OAAO,CAAC,IAAIK,MAAM,OAAAC,MAAA,CAAOF,CAAC,UAAO,GAAG,CAAC,MAAAE,MAAA,CAAMF,CAAC,MAAG,CAAC;QAC1D,CAAC,CAAC;QACF,OAAOd,CAAC;MACZ;;MAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAvCI;MAAAhB,GAAA;MAAAC,KAAA,EAwCA,SAAAG,MAAM6B,GAAG,EAAE;QACP;QACAA,GAAG,GAAG,IAAI,CAACR,kBAAkB,CAACQ,GAAG,CAAC;QAClC;QACA,OAAO,IAAI,CAACC,SAAS,CAACD,GAAG,CAAC;MAC9B;;MAEA;AACJ;AACA;AACA;AACA;IAJI;MAAAjC,GAAA;MAAAC,KAAA,EAKA,SAAAiC,UAAUD,GAAG,EAAE;QAAA,IAAAE,KAAA;QACX,IAAIC,QAAQ,GAAGH,GAAG,CAAC3C,MAAM,GAAG,CAAC;UACzB+C,GAAG,GAAG,CAAC;UACPC,KAAK,GAAG,CAAC;UACTC,WAAW,GAAG,EAAE;UAChBC,IAAI,GAAG,EAAE;UACTC,GAAG,GAAG,EAAE;UACRC,QAAQ,GAAG,IAAI;UACfjC,MAAM,GAAG,CAAC;QAEd,OAAO4B,GAAG,IAAID,QAAQ,EAAE;UACpB,QAAQE,KAAK;YACT,KAAK,CAAC;cACF;cACAE,IAAI,GAAGP,GAAG,CAACU,MAAM,CAACN,GAAG,CAAC;cACtB,IAAIG,IAAI,CAACI,KAAK,CAAC,QAAQ,CAAC,EAAE;gBACtB;gBACAN,KAAK,GAAG,WAAW;gBACnBG,GAAG,GAAG,EAAE;gBACRJ,GAAG,EAAE;cACT,CAAC,MAAM,IAAI,IAAI,CAACQ,UAAU,CAACL,IAAI,CAAC,EAAE;gBAC9B;gBACA;gBACA;gBACA;gBACA,IAAIA,IAAI,KAAK,GAAG,EAAE;kBACd,IAAID,WAAW,CAACjD,MAAM,KAAK,CAAC,IAAI,IAAI,CAACwD,cAAc,CAACP,WAAW,CAACA,WAAW,CAACjD,MAAM,GAAG,CAAC,CAAC,CAAC,EAAE;oBACtFgD,KAAK,GAAG,WAAW;oBACnBG,GAAG,GAAG,GAAG;oBACT;kBACJ;gBACJ;;gBAEA;gBACA,IAAIJ,GAAG,KAAKD,QAAQ,IAAI,IAAI,CAACU,cAAc,CAACP,WAAW,CAACA,WAAW,CAACjD,MAAM,GAAG,CAAC,CAAC,CAAC,EAAE;kBAC9EgD,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC;kBACZ;gBACJ,CAAC,MAAM;kBACHC,WAAW,CAACnB,IAAI,CAAC2B,UAAU,CAACC,wBAAwB,CAACR,IAAI,CAAC,CAAC;kBAC3DF,KAAK,GAAG,CAAC;gBACb;cACJ,CAAC,MAAM,IAAIE,IAAI,KAAK,GAAG,EAAE;gBACrB;gBACAF,KAAK,GAAG,oBAAoB;gBAC5BG,GAAG,GAAG,EAAE;gBACRhC,MAAM,GAAG,CAAC;cACd,CAAC,MAAM,IAAI+B,IAAI,KAAK,GAAG,EAAE;gBACrB;gBACAF,KAAK,GAAG,kBAAkB;gBAC1BG,GAAG,GAAG,EAAE;cACZ,CAAC,MAAM,IAAID,IAAI,CAACI,KAAK,CAAC,UAAU,CAAC,EAAE;gBAC/B;gBACA,IAAIP,GAAG,GAAGD,QAAQ,IAAIH,GAAG,CAACU,MAAM,CAACN,GAAG,GAAG,CAAC,CAAC,CAACO,KAAK,CAAC,cAAc,CAAC,EAAE;kBAC7DH,GAAG,GAAGD,IAAI;kBACVF,KAAK,GAAG,aAAa;gBACzB,CAAC,MAAM;kBACH;kBACA;kBACA;kBACA,IACIC,WAAW,CAACjD,MAAM,GAAG,CAAC,IACtBiD,WAAW,CAACA,WAAW,CAACjD,MAAM,GAAG,CAAC,CAAC,YAAY2D,eAAe,EAChE;oBACEV,WAAW,CAACnB,IAAI,CAAC2B,UAAU,CAACC,wBAAwB,CAAC,GAAG,CAAC,CAAC;kBAC9D;kBACAT,WAAW,CAACnB,IAAI,CAAC,IAAI8B,kBAAkB,CAACV,IAAI,CAAC,CAAC;kBAC9C,IAAI,CAACW,gBAAgB,CAACX,IAAI,CAAC;kBAC3BF,KAAK,GAAG,CAAC;kBACTG,GAAG,GAAG,EAAE;gBACZ;cACJ;cACA;YACJ,KAAK,WAAW;cACZD,IAAI,GAAGP,GAAG,CAACU,MAAM,CAACN,GAAG,CAAC;cACtB,IAAIG,IAAI,CAACI,KAAK,CAAC,QAAQ,CAAC,EAAE;gBACtB;gBACAH,GAAG,IAAID,IAAI;gBACX,IAAIH,GAAG,KAAKD,QAAQ,EAAE;kBAClBG,WAAW,CAACnB,IAAI,CAAC,IAAI6B,eAAe,CAACR,GAAG,CAAC,CAAC;kBAC1CH,KAAK,GAAG,CAAC;gBACb;cACJ,CAAC,MAAM;gBACH;gBACA,IAAIG,GAAG,KAAK,GAAG,EAAE;kBACb;kBACAA,GAAG,GAAG,CAAC,CAAC;gBACZ;gBACAF,WAAW,CAACnB,IAAI,CAAC,IAAI6B,eAAe,CAACR,GAAG,CAAC,CAAC;gBAC1CA,GAAG,GAAG,EAAE;gBACRH,KAAK,GAAG,CAAC;gBACTD,GAAG,EAAE;cACT;cACA;YAEJ,KAAK,aAAa;cACdG,IAAI,GAAGP,GAAG,CAACU,MAAM,CAACN,GAAG,CAAC;cACtB,IAAIG,IAAI,CAACI,KAAK,CAAC,cAAc,CAAC,EAAE;gBAC5BH,GAAG,IAAID,IAAI;cACf,CAAC,MAAM,IAAIA,IAAI,KAAK,GAAG,EAAE;gBACrBE,QAAQ,GAAGD,GAAG;gBACdA,GAAG,GAAG,EAAE;gBACRhC,MAAM,GAAG,CAAC;gBACV6B,KAAK,GAAG,yBAAyB;cACrC,CAAC,MAAM;gBACH,MAAM,IAAIjB,KAAK,CAAC,2CAA2C,GAAGgB,GAAG,CAAC;cACtE;cAEA;YAEJ,KAAK,kBAAkB;cACnBG,IAAI,GAAGP,GAAG,CAACU,MAAM,CAACN,GAAG,CAAC;cACtB,IAAIG,IAAI,KAAK,GAAG,EAAE;gBACd;gBACAD,WAAW,CAACnB,IAAI,CAAC,IAAI8B,kBAAkB,CAACT,GAAG,CAAC,CAAC;gBAC7C,IAAI,CAACU,gBAAgB,CAACV,GAAG,CAAC;gBAC1BA,GAAG,GAAG,EAAE;gBACRH,KAAK,GAAG,CAAC;cACb,CAAC,MAAM,IAAIE,IAAI,CAACI,KAAK,CAAC,eAAe,CAAC,EAAE;gBACpCH,GAAG,IAAID,IAAI;cACf,CAAC,MAAM;gBACH,MAAM,IAAInB,KAAK,CAAC,+CAA+C,GAAGmB,IAAI,CAAC;cAC3E;cACA;YAEJ,KAAK,oBAAoB;YACzB,KAAK,yBAAyB;cAC1BA,IAAI,GAAGP,GAAG,CAACU,MAAM,CAACN,GAAG,CAAC;cACtB,IAAIG,IAAI,KAAK,GAAG,EAAE;gBACd;gBACA,IAAI/B,MAAM,IAAI,CAAC,EAAE;kBACb;kBACA,IAAI6B,KAAK,KAAK,oBAAoB,EAAE;oBAChCC,WAAW,CAACnB,IAAI,CAAC,IAAIgC,iBAAiB,CAAC,IAAI,CAAClB,SAAS,CAACO,GAAG,CAAC,CAAC,CAAC;kBAChE,CAAC,MAAM,IAAIH,KAAK,KAAK,yBAAyB,EAAE;oBAC5C;oBACA;oBACA,IAAIe,IAAI,GAAG,IAAI,CAAC9C,mBAAmB,CAACkC,GAAG,CAAC,CAACa,GAAG,CAAC,UAACC,CAAC;sBAAA,OAAKpB,KAAI,CAACD,SAAS,CAACqB,CAAC,CAAC;oBAAA,EAAC;oBACtEhB,WAAW,CAACnB,IAAI,CAAC,IAAIoC,kBAAkB,CAACd,QAAQ,EAAEW,IAAI,EAAE,IAAI,CAAC,CAAC;oBAC9DX,QAAQ,GAAG,IAAI;kBACnB;kBACAJ,KAAK,GAAG,CAAC;gBACb,CAAC,MAAM;kBACH7B,MAAM,EAAE;kBACRgC,GAAG,IAAID,IAAI;gBACf;cACJ,CAAC,MAAM,IAAIA,IAAI,KAAK,GAAG,EAAE;gBACrB;gBACA/B,MAAM,EAAE;gBACRgC,GAAG,IAAID,IAAI;cACf,CAAC,MAAM;gBACH;gBACAC,GAAG,IAAID,IAAI;cACf;cACA;UACR;UACAH,GAAG,EAAE;QACT;QAEA,IAAIC,KAAK,KAAK,CAAC,EAAE;UACb,MAAM,IAAIjB,KAAK,CAAC,wCAAwC,CAAC;QAC7D;QAEA,OAAO,IAAI,CAACoC,mBAAmB,CAAClB,WAAW,CAAC;MAChD;;MAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IARI;MAAAvC,GAAA;MAAAC,KAAA,EASA,SAAAwD,oBAAoBlB,WAAW,EAAE;QAC7B,IAAIA,WAAW,CAACjD,MAAM,GAAG,CAAC,EAAE;UACxB,OAAO,IAAI;QACf;QACA,IAAMoE,QAAQ,GAAAC,kBAAA,CAAOpB,WAAW,CAAC;QACjC,IAAIqB,GAAG,GAAG,CAAC;QACX,IAAIC,IAAI,GAAG,IAAI;QACf;QACA,OAAOD,GAAG,GAAGF,QAAQ,CAACpE,MAAM,EAAE;UAC1BuE,IAAI,GAAGH,QAAQ,CAACE,GAAG,CAAC;UACpB,IAAIC,IAAI,YAAYC,eAAe,EAAE;YACjC,IAAIF,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAKF,QAAQ,CAACpE,MAAM,GAAG,CAAC,EAAE;cAC1C,MAAM,IAAI+B,KAAK,CAAC,0BAA0B,CAAC;YAC/C;YACAwC,IAAI,CAACE,IAAI,GAAGL,QAAQ,CAACE,GAAG,GAAG,CAAC,CAAC;YAC7BC,IAAI,CAACG,QAAQ,GAAGN,QAAQ,CAACE,GAAG,GAAG,CAAC,CAAC;YACjCF,QAAQ,CAACE,GAAG,GAAG,CAAC,CAAC,GAAGC,IAAI;YACxBH,QAAQ,CAACO,MAAM,CAACL,GAAG,EAAE,CAAC,CAAC;UAC3B,CAAC,MAAM;YACHA,GAAG,EAAE;UACT;QACJ;;QAEA;QACAA,GAAG,GAAG,CAAC;QACPC,IAAI,GAAG,IAAI;QACX,OAAOD,GAAG,GAAGF,QAAQ,CAACpE,MAAM,EAAE;UAC1BuE,IAAI,GAAGH,QAAQ,CAACE,GAAG,CAAC;UACpB,IAAIC,IAAI,YAAYK,iBAAiB,EAAE;YACnC,IAAIN,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAKF,QAAQ,CAACpE,MAAM,GAAG,CAAC,EAAE;cAC1C,MAAM,IAAI+B,KAAK,CAAC,0BAA0B,CAAC;YAC/C;YACAwC,IAAI,CAACM,IAAI,GAAGT,QAAQ,CAACE,GAAG,GAAG,CAAC,CAAC;YAC7BC,IAAI,CAACO,KAAK,GAAGV,QAAQ,CAACE,GAAG,GAAG,CAAC,CAAC;YAC9BF,QAAQ,CAACE,GAAG,GAAG,CAAC,CAAC,GAAGC,IAAI;YACxBH,QAAQ,CAACO,MAAM,CAACL,GAAG,EAAE,CAAC,CAAC;UAC3B,CAAC,MAAM;YACHA,GAAG,EAAE;UACT;QACJ;;QAEA;QACAA,GAAG,GAAG,CAAC;QACPC,IAAI,GAAG,IAAI;QACX,OAAOD,GAAG,GAAGF,QAAQ,CAACpE,MAAM,EAAE;UAC1BuE,IAAI,GAAGH,QAAQ,CAACE,GAAG,CAAC;UACpB,IAAIC,IAAI,YAAYQ,mBAAmB,EAAE;YACrC,IAAIT,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAKF,QAAQ,CAACpE,MAAM,GAAG,CAAC,EAAE;cAC1C,MAAM,IAAI+B,KAAK,CAAC,0BAA0B,CAAC;YAC/C;YACAwC,IAAI,CAACM,IAAI,GAAGT,QAAQ,CAACE,GAAG,GAAG,CAAC,CAAC;YAC7BC,IAAI,CAACO,KAAK,GAAGV,QAAQ,CAACE,GAAG,GAAG,CAAC,CAAC;YAC9BF,QAAQ,CAACE,GAAG,GAAG,CAAC,CAAC,GAAGC,IAAI;YACxBH,QAAQ,CAACO,MAAM,CAACL,GAAG,EAAE,CAAC,CAAC;UAC3B,CAAC,MAAM;YACHA,GAAG,EAAE;UACT;QACJ;QACA,IAAIF,QAAQ,CAACpE,MAAM,KAAK,CAAC,EAAE;UACvB,MAAM,IAAI+B,KAAK,CAAC,4CAA4C,CAAC;QACjE;QACA,OAAOqC,QAAQ,CAAC,CAAC,CAAC;MACtB;IAAC;MAAA1D,GAAA;MAAAC,KAAA,EAED,SAAA4C,WAAWL,IAAI,EAAE;QACb,OAAO,OAAOA,IAAI,KAAK,QAAQ,IAAIA,IAAI,CAACI,KAAK,CAAC,UAAU,CAAC;MAC7D;IAAC;MAAA5C,GAAA;MAAAC,KAAA,EAED,SAAA6C,eAAee,IAAI,EAAE;QACjB,OACIA,IAAI,YAAYQ,mBAAmB,IAAIR,IAAI,YAAYK,iBAAiB,IAAIL,IAAI,YAAYC,eAAe;MAEnH;IAAC;MAAA9D,GAAA;MAAAC,KAAA,EAED,SAAAkD,iBAAiBmB,OAAO,EAAE;QACtB,IAAI,IAAI,CAAC1E,UAAU,CAAC2E,OAAO,CAACD,OAAO,CAAC,GAAG,CAAC,EAAE;UACtC,IAAI,CAAC1E,UAAU,CAACwB,IAAI,CAACkD,OAAO,CAAC;QACjC;MACJ;IAAC;MAAAtE,GAAA;MAAAC,KAAA,EAED,SAAAuE,aAAA,EAAe;QACX,OAAO,IAAI,CAAC5E,UAAU;MAC1B;;MAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAVI;MAAAI,GAAA;MAAAC,KAAA,EAWA,SAAAwE,SAASC,QAAQ,EAAE;QAAA,IAAAC,MAAA;QACf;QACA,IAAID,QAAQ,YAAYE,KAAK,EAAE;UAC3B,OAAOF,QAAQ,CAACpB,GAAG,CAAC,UAACuB,CAAC;YAAA,OAAKF,MAAI,CAACF,QAAQ,CAACI,CAAC,CAAC;UAAA,EAAC;QAChD;QACA,IAAIhB,IAAI,GAAG,IAAI,CAACiB,aAAa,CAAC,CAAC;QAC/B,IAAI,EAAEjB,IAAI,YAAYd,UAAU,CAAC,EAAE;UAC/B,MAAM,IAAI1B,KAAK,CAAC,4DAA4D,CAAC;QACjF;QACA,IAAI,IAAI,CAACjC,OAAO,CAACO,WAAW,EAAE;UAC1B,IAAIoF,GAAG,GAAG,IAAI,CAACC,gBAAgB,CAACN,QAAQ,CAAC;UACzC,IAAIK,GAAG,KAAK,IAAI,EAAE;YACd,OAAOA,GAAG;UACd,CAAC,MAAM;YACHA,GAAG,GAAGlB,IAAI,CAACY,QAAQ,CAAA/E,aAAA,CAAAA,aAAA,KAAMpB,cAAc,GAAKoG,QAAQ,CAAE,CAAC;YACvD,IAAI,CAACO,aAAa,CAACP,QAAQ,EAAEK,GAAG,CAAC;YACjC,OAAOA,GAAG;UACd;QACJ;QACA,OAAOlB,IAAI,CAACY,QAAQ,CAAA/E,aAAA,CAAAA,aAAA,KAAMpB,cAAc,GAAKoG,QAAQ,CAAE,CAAC;MAC5D;IAAC;MAAA1E,GAAA;MAAAC,KAAA,EAED,SAAAiF,WAAWR,QAAQ,EAAE;QACjB,OAAOS,IAAI,CAACC,SAAS,CAACV,QAAQ,CAAC;MACnC;IAAC;MAAA1E,GAAA;MAAAC,KAAA,EAED,SAAA+E,iBAAiBN,QAAQ,EAAE;QACvB,IAAI1E,GAAG,GAAG,IAAI,CAACkF,UAAU,CAACR,QAAQ,CAAC;QACnC,IAAIK,GAAG,GAAG,IAAI,CAAClF,OAAO,CAACG,GAAG,CAAC;QAC3B,IAAI+E,GAAG,KAAKxF,SAAS,EAAE;UACnB,OAAOwF,GAAG;QACd,CAAC,MAAM;UACH,OAAO,IAAI;QACf;MACJ;IAAC;MAAA/E,GAAA;MAAAC,KAAA,EAED,SAAAgF,cAAcP,QAAQ,EAAEzE,KAAK,EAAE;QAC3B,IAAI,CAACJ,OAAO,CAAC,IAAI,CAACqF,UAAU,CAACR,QAAQ,CAAC,CAAC,GAAGzE,KAAK;MACnD;IAAC;MAAAD,GAAA;MAAAC,KAAA,EAED,SAAA6E,cAAA,EAAgB;QACZ,OAAO,IAAI,CAACrF,iBAAiB;MACjC;IAAC;MAAAO,GAAA;MAAAC,KAAA,EAED,SAAAoF,oBAAA,EAAsB;QAClB,OAAO,IAAI,CAAC5F,iBAAiB,GAAG,IAAI,CAACA,iBAAiB,CAAC6F,QAAQ,CAAC,CAAC,GAAG,EAAE;MAC1E;IAAC;MAAAtF,GAAA;MAAAC,KAAA,EAED,SAAAsF,KAAYC,OAAO,EAAEd,QAAQ,EAAgB;QAAA,IAAdtF,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;QACvCqF,QAAQ,GAAGA,QAAQ,IAAI,CAAC,CAAC;QACzB,OAAO,IAAI1F,OAAO,CAACwG,OAAO,EAAEpG,OAAO,CAAC,CAACqF,QAAQ,CAACC,QAAQ,CAAC;MAC3D;IAAC;IAAA,OAAA1F,OAAA;EAAA;EAAA,IAGC+D,UAAU;IAAA,SAAAA,WAAA;MAAAvD,eAAA,OAAAuD,UAAA;IAAA;IAAAhD,YAAA,CAAAgD,UAAA;MAAA/C,GAAA;MAAAC,KAAA,EAcZ,SAAAwE,SAAA,EAAsB;QAAA,IAAb9D,MAAM,GAAAtB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;QAChB,MAAM,IAAIgC,KAAK,CAAC,kCAAkC,CAAC;MACvD;IAAC;MAAArB,GAAA;MAAAC,KAAA,EAED,SAAAqF,SAAA,EAAW;QACP,OAAO,EAAE;MACb;IAAC;MAAAtF,GAAA;MAAAC,KAAA,EAnBD,SAAA+C,yBAAgCyC,QAAQ,EAA6B;QAAA,IAA3BtB,IAAI,GAAA9E,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;QAAA,IAAE+E,KAAK,GAAA/E,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;QAC/D,IAAIoG,QAAQ,KAAK,GAAG,EAAE;UAClB,OAAO,IAAI3B,eAAe,CAAC2B,QAAQ,EAAEtB,IAAI,EAAEC,KAAK,CAAC;QACrD;QACA,IAAIqB,QAAQ,KAAK,GAAG,IAAIA,QAAQ,KAAK,GAAG,EAAE;UACtC,OAAO,IAAIvB,iBAAiB,CAACuB,QAAQ,EAAEtB,IAAI,EAAEC,KAAK,CAAC;QACvD;QACA,IAAIqB,QAAQ,KAAK,GAAG,IAAIA,QAAQ,KAAK,GAAG,EAAE;UACtC,OAAO,IAAIpB,mBAAmB,CAACoB,QAAQ,EAAEtB,IAAI,EAAEC,KAAK,CAAC;QACzD;QACA,MAAM,IAAI/C,KAAK,sBAAAW,MAAA,CAAsByD,QAAQ,CAAE,CAAC;MACpD;IAAC;IAAA,OAAA1C,UAAA;EAAA;EAAA,IAWCK,iBAAiB,0BAAAsC,WAAA;IAAAC,SAAA,CAAAvC,iBAAA,EAAAsC,WAAA;IAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAzC,iBAAA;IACnB,SAAAA,kBAAYS,IAAI,EAAE;MAAA,IAAAiC,MAAA;MAAAtG,eAAA,OAAA4D,iBAAA;MACd0C,MAAA,GAAAF,MAAA,CAAAG,IAAA;MACAD,MAAA,CAAKE,eAAe,GAAGnC,IAAI;MAC3B,IAAI,EAAEiC,MAAA,CAAKE,eAAe,YAAYjD,UAAU,CAAC,EAAE;QAC/C,MAAM,IAAI1B,KAAK,CAAC,kDAAkD,CAAC;MACvE;MAAC,OAAAyE,MAAA;IACL;IAAC/F,YAAA,CAAAqD,iBAAA;MAAApD,GAAA;MAAAC,KAAA,EACD,SAAAwE,SAAA,EAAsB;QAAA,IAAb9D,MAAM,GAAAtB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;QAChB,OAAO,IAAI,CAAC2G,eAAe,CAACvB,QAAQ,CAAC9D,MAAM,CAAC;MAChD;IAAC;MAAAX,GAAA;MAAAC,KAAA,EACD,SAAAqF,SAAA,EAAW;QACP,WAAAtD,MAAA,CAAW,IAAI,CAACgE,eAAe,CAACV,QAAQ,CAAC,CAAC;MAC9C;IAAC;IAAA,OAAAlC,iBAAA;EAAA,EAb2BL,UAAU;EAAA,IAgBpCE,eAAe,0BAAAgD,YAAA;IAAAN,SAAA,CAAA1C,eAAA,EAAAgD,YAAA;IAAA,IAAAC,OAAA,GAAAL,YAAA,CAAA5C,eAAA;IACjB,SAAAA,gBAAYhD,KAAK,EAAE;MAAA,IAAAkG,MAAA;MAAA3G,eAAA,OAAAyD,eAAA;MACfkD,MAAA,GAAAD,OAAA,CAAAH,IAAA;MACAI,MAAA,CAAKlG,KAAK,GAAGmG,MAAM,CAACnG,KAAK,CAAC;MAC1B,IAAIoG,KAAK,CAACF,MAAA,CAAKlG,KAAK,CAAC,EAAE;QACnB,MAAM,IAAIoB,KAAK,CAAC,uBAAuB,GAAGpB,KAAK,CAAC;MACpD;MAAC,OAAAkG,MAAA;IACL;IAACpG,YAAA,CAAAkD,eAAA;MAAAjD,GAAA;MAAAC,KAAA,EACD,SAAAwE,SAAA,EAAsB;QAAA,IAAb9D,MAAM,GAAAtB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;QAChB,OAAO,IAAI,CAACY,KAAK;MACrB;IAAC;MAAAD,GAAA;MAAAC,KAAA,EACD,SAAAqF,SAAA,EAAW;QACP,OAAOgB,MAAM,CAAC,IAAI,CAACrG,KAAK,CAAC;MAC7B;IAAC;IAAA,OAAAgD,eAAA;EAAA,EAbyBF,UAAU;EAAA,IAgBlCsB,mBAAmB,0BAAAkC,YAAA;IAAAZ,SAAA,CAAAtB,mBAAA,EAAAkC,YAAA;IAAA,IAAAC,OAAA,GAAAX,YAAA,CAAAxB,mBAAA;IACrB,SAAAA,oBAAYoB,QAAQ,EAA6B;MAAA,IAAAgB,MAAA;MAAA,IAA3BtC,IAAI,GAAA9E,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;MAAA,IAAE+E,KAAK,GAAA/E,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;MAAAG,eAAA,OAAA6E,mBAAA;MAC3CoC,MAAA,GAAAD,OAAA,CAAAT,IAAA;MACA,IAAI,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,CAACW,QAAQ,CAACjB,QAAQ,CAAC,EAAE;QAChC,MAAM,IAAIpE,KAAK,mDAAAW,MAAA,CAAmDyD,QAAQ,CAAE,CAAC;MACjF;MACAgB,MAAA,CAAKhB,QAAQ,GAAGA,QAAQ;MACxBgB,MAAA,CAAKtC,IAAI,GAAGA,IAAI;MAChBsC,MAAA,CAAKrC,KAAK,GAAGA,KAAK;MAAC,OAAAqC,MAAA;IACvB;IAAC1G,YAAA,CAAAsE,mBAAA;MAAArE,GAAA;MAAAC,KAAA,EAED,SAAAwE,SAAA,EAAsB;QAAA,IAAb9D,MAAM,GAAAtB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;QAChB,IAAI,IAAI,CAACoG,QAAQ,KAAK,GAAG,EAAE;UACvB,OAAO,IAAI,CAACtB,IAAI,CAACM,QAAQ,CAAC9D,MAAM,CAAC,GAAG,IAAI,CAACyD,KAAK,CAACK,QAAQ,CAAC9D,MAAM,CAAC;QACnE;QACA,IAAI,IAAI,CAAC8E,QAAQ,KAAK,GAAG,EAAE;UACvB,OAAO,IAAI,CAACtB,IAAI,CAACM,QAAQ,CAAC9D,MAAM,CAAC,GAAG,IAAI,CAACyD,KAAK,CAACK,QAAQ,CAAC9D,MAAM,CAAC;QACnE;QACA,MAAM,IAAIU,KAAK,CAAC,2CAA2C,CAAC;MAChE;IAAC;MAAArB,GAAA;MAAAC,KAAA,EAED,SAAAqF,SAAA,EAAW;QACP,UAAAtD,MAAA,CAAU,IAAI,CAACmC,IAAI,CAACmB,QAAQ,CAAC,CAAC,OAAAtD,MAAA,CAAI,IAAI,CAACyD,QAAQ,OAAAzD,MAAA,CAAI,IAAI,CAACoC,KAAK,CAACkB,QAAQ,CAAC,CAAC;MAC5E;IAAC;IAAA,OAAAjB,mBAAA;EAAA,EAvB6BtB,UAAU;EAAA,IA0BtCmB,iBAAiB,0BAAAyC,YAAA;IAAAhB,SAAA,CAAAzB,iBAAA,EAAAyC,YAAA;IAAA,IAAAC,OAAA,GAAAf,YAAA,CAAA3B,iBAAA;IACnB,SAAAA,kBAAYuB,QAAQ,EAA6B;MAAA,IAAAoB,MAAA;MAAA,IAA3B1C,IAAI,GAAA9E,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;MAAA,IAAE+E,KAAK,GAAA/E,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;MAAAG,eAAA,OAAA0E,iBAAA;MAC3C2C,MAAA,GAAAD,OAAA,CAAAb,IAAA;MACA,IAAI,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,CAACW,QAAQ,CAACjB,QAAQ,CAAC,EAAE;QAChC,MAAM,IAAIpE,KAAK,0DAAAW,MAAA,CAA0DyD,QAAQ,CAAE,CAAC;MACxF;MACAoB,MAAA,CAAKpB,QAAQ,GAAGA,QAAQ;MACxBoB,MAAA,CAAK1C,IAAI,GAAGA,IAAI;MAChB0C,MAAA,CAAKzC,KAAK,GAAGA,KAAK;MAAC,OAAAyC,MAAA;IACvB;IAAC9G,YAAA,CAAAmE,iBAAA;MAAAlE,GAAA;MAAAC,KAAA,EAED,SAAAwE,SAAA,EAAsB;QAAA,IAAb9D,MAAM,GAAAtB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;QAChB,IAAI,IAAI,CAACoG,QAAQ,KAAK,GAAG,EAAE;UACvB,OAAO,IAAI,CAACtB,IAAI,CAACM,QAAQ,CAAC9D,MAAM,CAAC,GAAG,IAAI,CAACyD,KAAK,CAACK,QAAQ,CAAC9D,MAAM,CAAC;QACnE;QACA,IAAI,IAAI,CAAC8E,QAAQ,KAAK,GAAG,EAAE;UACvB,OAAO,IAAI,CAACtB,IAAI,CAACM,QAAQ,CAAC9D,MAAM,CAAC,GAAG,IAAI,CAACyD,KAAK,CAACK,QAAQ,CAAC9D,MAAM,CAAC;QACnE;QACA,MAAM,IAAIU,KAAK,CAAC,yCAAyC,CAAC;MAC9D;IAAC;MAAArB,GAAA;MAAAC,KAAA,EAED,SAAAqF,SAAA,EAAW;QACP,UAAAtD,MAAA,CAAU,IAAI,CAACmC,IAAI,CAACmB,QAAQ,CAAC,CAAC,OAAAtD,MAAA,CAAI,IAAI,CAACyD,QAAQ,OAAAzD,MAAA,CAAI,IAAI,CAACoC,KAAK,CAACkB,QAAQ,CAAC,CAAC;MAC5E;IAAC;IAAA,OAAApB,iBAAA;EAAA,EAvB2BnB,UAAU;EAAA,IA0BpCe,eAAe,0BAAAgD,YAAA;IAAAnB,SAAA,CAAA7B,eAAA,EAAAgD,YAAA;IAAA,IAAAC,OAAA,GAAAlB,YAAA,CAAA/B,eAAA;IACjB,SAAAA,gBAAA,EAA0C;MAAA,IAAAkD,MAAA;MAAA,IAA9BjD,IAAI,GAAA1E,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;MAAA,IAAE2E,QAAQ,GAAA3E,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;MAAAG,eAAA,OAAAsE,eAAA;MACpCkD,MAAA,GAAAD,OAAA,CAAAhB,IAAA;MACAiB,MAAA,CAAKjD,IAAI,GAAGA,IAAI;MAChBiD,MAAA,CAAKhD,QAAQ,GAAGA,QAAQ;MAAC,OAAAgD,MAAA;IAC7B;IAACjH,YAAA,CAAA+D,eAAA;MAAA9D,GAAA;MAAAC,KAAA,EAED,SAAAwE,SAAA,EAAsB;QAAA,IAAb9D,MAAM,GAAAtB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;QAChB,OAAOb,IAAI,CAACyI,GAAG,CAAC,IAAI,CAAClD,IAAI,CAACU,QAAQ,CAAC9D,MAAM,CAAC,EAAE,IAAI,CAACqD,QAAQ,CAACS,QAAQ,CAAC9D,MAAM,CAAC,CAAC;MAC/E;IAAC;MAAAX,GAAA;MAAAC,KAAA,EAED,SAAAqF,SAAA,EAAW;QACP,UAAAtD,MAAA,CAAU,IAAI,CAAC+B,IAAI,CAACuB,QAAQ,CAAC,CAAC,OAAAtD,MAAA,CAAI,IAAI,CAACgC,QAAQ,CAACsB,QAAQ,CAAC,CAAC;MAC9D;IAAC;IAAA,OAAAxB,eAAA;EAAA,EAbyBf,UAAU;EAAA,IAelCS,kBAAkB,0BAAA0D,YAAA;IAAAvB,SAAA,CAAAnC,kBAAA,EAAA0D,YAAA;IAAA,IAAAC,OAAA,GAAAtB,YAAA,CAAArC,kBAAA;IACpB,SAAAA,mBAAY4D,EAAE,EAAEC,mBAAmB,EAAwB;MAAA,IAAAC,MAAA;MAAA,IAAtBC,aAAa,GAAAlI,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;MAAAG,eAAA,OAAAgE,kBAAA;MACrD8D,MAAA,GAAAH,OAAA,CAAApB,IAAA;MACAuB,MAAA,CAAKF,EAAE,GAAGA,EAAE;MACZE,MAAA,CAAKD,mBAAmB,GAAGA,mBAAmB,IAAI,EAAE;MACpDC,MAAA,CAAKC,aAAa,GAAGA,aAAa;MAClCD,MAAA,CAAKE,WAAW,GAAGjI,SAAS;MAAC,OAAA+H,MAAA;IACjC;IAACvH,YAAA,CAAAyD,kBAAA;MAAAxD,GAAA;MAAAC,KAAA,EAED,SAAAwE,SAAA,EAAsB;QAAA,IAAb9D,MAAM,GAAAtB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;QAChBsB,MAAM,GAAGA,MAAM,IAAI,CAAC,CAAC;QACrB,IAAM8G,WAAW,GAAG,IAAI,CAACJ,mBAAmB,CAAC/D,GAAG,CAAC,UAACC,CAAC;UAAA,OAAKA,CAAC,CAACkB,QAAQ,CAAC9D,MAAM,CAAC;QAAA,EAAC;;QAE3E;QACA;QACA,IAAIA,MAAM,CAAC,IAAI,CAACyG,EAAE,CAAC,YAAYM,QAAQ,EAAE;UACrC,OAAO/G,MAAM,CAAC,IAAI,CAACyG,EAAE,CAAC,CAACO,KAAK,CAAC,IAAI,EAAEF,WAAW,CAAC;QACnD;QACA;QAAA,KACK,IAAI,IAAI,CAACF,aAAa,IAAI,IAAI,CAACA,aAAa,CAAC,IAAI,CAACH,EAAE,CAAC,YAAYM,QAAQ,EAAE;UAC5E;UACA,IAAI,IAAI,CAACE,aAAa,CAAC,CAAC,EAAE;YACtB,MAAM,IAAIvG,KAAK,CAAC,+BAA+B,GAAG,IAAI,CAAC+F,EAAE,CAAC;UAC9D;UACA,OAAO,IAAI,CAACG,aAAa,CAAC,IAAI,CAACH,EAAE,CAAC,CAACO,KAAK,CAAC,IAAI,CAACJ,aAAa,EAAEE,WAAW,CAAC;QAC7E;QACA;QAAA,KACK,IAAIjJ,IAAI,CAAC,IAAI,CAAC4I,EAAE,CAAC,YAAYM,QAAQ,EAAE;UACxC,OAAOlJ,IAAI,CAAC,IAAI,CAAC4I,EAAE,CAAC,CAACO,KAAK,CAAC,IAAI,EAAEF,WAAW,CAAC;QACjD;QACA;QAAA,KACK;UACD,MAAM,IAAIpG,KAAK,CAAC,sBAAsB,GAAG,IAAI,CAAC+F,EAAE,CAAC;QACrD;MACJ;IAAC;MAAApH,GAAA;MAAAC,KAAA,EAED,SAAAqF,SAAA,EAAW;QACP,UAAAtD,MAAA,CAAU,IAAI,CAACoF,EAAE,OAAApF,MAAA,CAAI,IAAI,CAACqF,mBAAmB,CAAC/D,GAAG,CAAC,UAACC,CAAC;UAAA,OAAKA,CAAC,CAAC+B,QAAQ,CAAC,CAAC;QAAA,EAAC,CAACuC,IAAI,CAAC,IAAI,CAAC;MACrF;IAAC;MAAA7H,GAAA;MAAAC,KAAA,EAED,SAAA2H,cAAA,EAAgB;QACZ;QACA,IAAI,IAAI,CAACJ,WAAW,KAAKjI,SAAS,EAAE;UAChC,IAAI,CAACiI,WAAW,GAAGxI,OAAO,CAAC8I,iBAAiB,CAACpB,QAAQ,CACjD,IAAI,CAACa,aAAa,GAAG,IAAI,CAACA,aAAa,CAAC,IAAI,CAACH,EAAE,CAAC,GAAG,IACvD,CAAC;QACL;QACA,OAAO,IAAI,CAACI,WAAW;MAC3B;IAAC;IAAA,OAAAhE,kBAAA;EAAA,EAhD4BT,UAAU;EAmD3C,SAASgF,WAAWA,CAACC,MAAM,EAAEC,IAAI,EAAEC,QAAQ,EAAE;IACzC,IAAIC,IAAI,GAAGH,MAAM;IACjB,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,IAAI,CAAC3I,MAAM,EAAE8I,CAAC,EAAE,EAAE;MAClC,IAAID,IAAI,CAACF,IAAI,CAACG,CAAC,CAAC,CAAC,KAAK7I,SAAS,EAAE;QAC7B,MAAM,IAAI8B,KAAK,oBAAAW,MAAA,CAAoBiG,IAAI,CAACG,CAAC,CAAC,sCAAApG,MAAA,CAAmCkG,QAAQ,MAAG,CAAC;MAC7F;MAEAC,IAAI,GAAGA,IAAI,CAACF,IAAI,CAACG,CAAC,CAAC,CAAC;IACxB;IAEA,IAAIC,OAAA,CAAOF,IAAI,MAAK,QAAQ,EAAE;MAC1B,MAAM,IAAI9G,KAAK,CAAC,eAAe,CAAC;IACpC;IAEA,OAAO8G,IAAI;EACf;EAAC,IAEKjF,kBAAkB,0BAAAoF,YAAA;IAAA3C,SAAA,CAAAzC,kBAAA,EAAAoF,YAAA;IAAA,IAAAC,OAAA,GAAA1C,YAAA,CAAA3C,kBAAA;IACpB,SAAAA,mBAAYgF,QAAQ,EAAE;MAAA,IAAAM,MAAA;MAAAhJ,eAAA,OAAA0D,kBAAA;MAClBsF,MAAA,GAAAD,OAAA,CAAAxC,IAAA;MACAyC,MAAA,CAAKN,QAAQ,GAAGA,QAAQ;MACxBM,MAAA,CAAKC,OAAO,GAAGP,QAAQ,CAACpH,KAAK,CAAC,GAAG,CAAC;MAAC,OAAA0H,MAAA;IACvC;IAACzI,YAAA,CAAAmD,kBAAA;MAAAlD,GAAA;MAAAC,KAAA,EAED,SAAAwE,SAAA,EAAsB;QAAA,IAAb9D,MAAM,GAAAtB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;QAChB;QACA;QACA;QACA;QACA;QACA;QACA,OAAO+G,MAAM,CAAC2B,WAAW,CAACpH,MAAM,EAAE,IAAI,CAAC8H,OAAO,EAAE,IAAI,CAACP,QAAQ,CAAC,CAAC;MACnE;IAAC;MAAAlI,GAAA;MAAAC,KAAA,EACD,SAAAqF,SAAA,EAAW;QACP,UAAAtD,MAAA,CAAU,IAAI,CAACyG,OAAO,CAACZ,IAAI,CAAC,GAAG,CAAC;MACpC;IAAC;IAAA,OAAA3E,kBAAA;EAAA,EAlB4BH,UAAU;EAqB3C/D,OAAO,CAAC+D,UAAU,GAAGA,UAAU;EAC/B/D,OAAO,CAACoE,iBAAiB,GAAGA,iBAAiB;EAC7CpE,OAAO,CAAC8E,eAAe,GAAGA,eAAe;EACzC9E,OAAO,CAACkF,iBAAiB,GAAGA,iBAAiB;EAC7ClF,OAAO,CAACqF,mBAAmB,GAAGA,mBAAmB;EACjDrF,OAAO,CAACiE,eAAe,GAAGA,eAAe;EACzCjE,OAAO,CAACkE,kBAAkB,GAAGA,kBAAkB;EAC/ClE,OAAO,CAACwE,kBAAkB,GAAGA,kBAAkB;EAC/CxE,OAAO,CAACV,cAAc,GAAGA,cAAc;;EAEvC;EACAU,OAAO,CAAC8I,iBAAiB,GAAGnG,MAAM,CAAC+G,mBAAmB,CAAC1J,OAAO,CAAC2J,SAAS,CAAC,CACpEC,MAAM,CAAC,UAACC,IAAI;IAAA,OAAK7J,OAAO,CAAC2J,SAAS,CAACE,IAAI,CAAC,YAAYnB,QAAQ;EAAA,EAAC,CAC7DpE,GAAG,CAAC,UAACuF,IAAI;IAAA,OAAK7J,OAAO,CAAC2J,SAAS,CAACE,IAAI,CAAC;EAAA,EAAC;EAACC,MAAA,CAAAC,OAAA,GAAAA,OAAA,CAAA7J,OAAA;AAAA;;;;;;UChuB5C;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UEtBA;UACA;UACA;UACA","sources":["webpack://Formula/webpack/universalModuleDefinition","webpack://Formula/./src/fparser.js","webpack://Formula/webpack/bootstrap","webpack://Formula/webpack/before-startup","webpack://Formula/webpack/startup","webpack://Formula/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Formula\"] = factory();\n\telse\n\t\troot[\"Formula\"] = factory();\n})(this, () => {\nreturn ","/**\n * JS Formula Parser\n * -------------------\n * (c) 2012-2023 Alexander Schenkel, alex@alexi.ch\n *\n * JS Formula Parser takes a string, parses its mathmatical formula\n * and creates an evaluatable Formula object of it.\n *\n * Example input:\n *\n * var fObj = new Formula('sin(PI*x)/(2*PI)');\n * var result = fObj.evaluate({x: 2});\n * var results = fObj.evaluate([\n *     {x: 2},\n *     {x: 4},\n *     {x: 8}\n * ]);\n *\n * LICENSE:\n * -------------\n * MIT license, see LICENSE file\n */\nconst MATH_CONSTANTS = {\n    PI: Math.PI,\n    E: Math.E,\n    LN2: Math.LN2,\n    LN10: Math.LN10,\n    LOG2E: Math.LOG2E,\n    LOG10E: Math.LOG10E,\n    SQRT1_2: Math.SQRT1_2,\n    SQRT2: Math.SQRT2\n};\nexport default class Formula {\n    /**\n     * Creates a new Formula instance\n     *\n     * Optional configuration can be set in the options object:\n     *\n     * - memoization (bool): If true, results are stored and re-used when evaluate() is called with the same parameters\n     *\n     * @param {String} fStr The formula string, e.g. 'sin(x)/cos(y)'\n     * @param {Object} options An options object. Supported options:\n     *    - memoization (bool): If true, results are stored and re-used when evaluate() is called with the same parameters\n     * @param {Formula} parentFormula Internally used to build a Formula AST\n     */\n    constructor(fStr, options = {}) {\n        this.formulaExpression = null;\n        this.options = {...{memoization: false}, ...options};\n        this._variables = [];\n        this._memory = {};\n        this.setFormula(fStr);\n    }\n\n    /**\n     * Re-sets the given String and parses it to a formula expression. Can be used after initialization,\n     * to re-use the Formula object.\n     *\n     * @param {String} formulaString The formula string to set/parse\n     * @return {this} The Formula object (this)\n     */\n    setFormula(formulaString) {\n        if (formulaString) {\n            this.formulaExpression = null;\n            this._variables = [];\n            this._memory = {};\n            this.formulaStr = formulaString;\n            this.formulaExpression = this.parse(formulaString);\n        }\n        return this;\n    }\n\n    /**\n     * Enable memoization: An expression is only evaluated once for the same input.\n     * Further evaluations with the same input will return the in-memory stored result.\n     */\n    enableMemoization() {\n        this.options.memoization = true;\n    }\n\n    /**\n     * Disable in-memory memoization: each call to evaluate() is executed from scratch.\n     */\n    disableMemoization() {\n        this.options.memoization = false;\n        this._memory = {};\n    }\n\n    /**\n     * Splits the given string by ',', makes sure the ',' is not within\n     * a sub-expression\n     * e.g.: str = \"x,pow(3,4)\" returns 2 elements: x and pow(3,4).\n     */\n    splitFunctionParams(toSplit) {\n        // do not split on ',' within matching brackets.\n        let pCount = 0,\n            paramStr = '';\n        const params = [];\n        for (let chr of toSplit.split('')) {\n            if (chr === ',' && pCount === 0) {\n                // Found function param, save 'em\n                params.push(paramStr);\n                paramStr = '';\n            } else if (chr === '(') {\n                pCount++;\n                paramStr += chr;\n            } else if (chr === ')') {\n                pCount--;\n                paramStr += chr;\n                if (pCount < 0) {\n                    throw new Error('ERROR: Too many closing parentheses!');\n                }\n            } else {\n                paramStr += chr;\n            }\n        }\n        if (pCount !== 0) {\n            throw new Error('ERROR: Too many opening parentheses!');\n        }\n        if (paramStr.length > 0) {\n            params.push(paramStr);\n        }\n        return params;\n    }\n\n    /**\n     * Cleans the input string from unnecessary whitespace,\n     * and replaces some known constants:\n     */\n    cleanupInputString(s) {\n        s = s.replace(/\\s+/g, '');\n        // surround known math constants with [], to parse them as named variables [xxx]:\n        Object.keys(MATH_CONSTANTS).forEach((c) => {\n            s = s.replace(new RegExp(`\\\\b${c}\\\\b`, 'g'), `[${c}]`);\n        });\n        return s;\n    }\n\n    /**\n     * Parses the given formula string by using a state machine into a single Expression object,\n     * which represents an expression tree (aka AST).\n     *\n     * First, we split the string into 'expression': An expression can be:\n     *   - a number, e.g. '3.45'\n     *   - an unknown variable, e.g. 'x'\n     *   - a single char operator, such as '*','+' etc...\n     *   - a named variable, in [], e.g. [myvar]\n     *   - a function, such as sin(x)\n     *   - a parenthessed expression, containing other expressions\n     *\n     * We want to create an expression tree out of the string. This is done in 2 stages:\n     * 1. form single expressions from the string: parse the string into known expression objects:\n     *   - numbers/variables\n     *   - operators\n     *   - braces (with a sub-expression)\n     *   - functions (with sub-expressions (aka argument expressions))\n     *   This will lead to an array of expressions.\n     *  As an example:\n     *  \"2 + 3 * (4 + 3 ^ 5) * sin(PI * x)\" forms an array of the following expressions:\n     *  `[2, +, 3, *, bracketExpr(4,+,3,^,5), * , functionExpr(PI,*,x)]`\n     * 2. From the raw expression array we form an expression tree by evaluating the expressions in the correct order:\n     *    e.g.:\n     *  the expression array `[2, +, 3, *, bracketExpr(4,+,3,^,5), * , functionExpr(PI,*,x)]` will be transformed into the expression tree:\n     *  ```\n     *         root expr:  (+)\n     *                     / \\\n     *                    2    (*)\n     *                        / \\\n     *                     (*)  functionExpr(...)\n     *                     / \\\n     *                    3   (bracket(..))\n     * ```\n     *\n     * In the end, we have a single root expression node, which then can be evaluated in the evaluate() function.\n     *\n     * @param {String} str The formula string, e.g. '3*sin(PI/x)'\n     * @returns {Expression} An expression object, representing the expression tree\n     */\n    parse(str) {\n        // clean the input string first. spaces, math constant replacements etc.:\n        str = this.cleanupInputString(str);\n        // start recursive call to parse:\n        return this._do_parse(str);\n    }\n\n    /**\n     * @see parse(): this is the recursive parse function, without the clean string part.\n     * @param {String} str\n     * @returns {Expression} An expression object, representing the expression tree\n     */\n    _do_parse(str) {\n        let lastChar = str.length - 1,\n            act = 0,\n            state = 0,\n            expressions = [],\n            char = '',\n            tmp = '',\n            funcName = null,\n            pCount = 0;\n\n        while (act <= lastChar) {\n            switch (state) {\n                case 0:\n                    // None state, the beginning. Read a char and see what happens.\n                    char = str.charAt(act);\n                    if (char.match(/[0-9.]/)) {\n                        // found the beginning of a number, change state to \"within-number\"\n                        state = 'within-nr';\n                        tmp = '';\n                        act--;\n                    } else if (this.isOperator(char)) {\n                        // Simple operators. Note: '-' must be treaten specially,\n                        // it could be part of a number.\n                        // it MUST be part of a number if the last found expression\n                        // was an operator (or the beginning):\n                        if (char === '-') {\n                            if (expressions.length === 0 || this.isOperatorExpr(expressions[expressions.length - 1])) {\n                                state = 'within-nr';\n                                tmp = '-';\n                                break;\n                            }\n                        }\n\n                        // Found a simple operator, store as expression:\n                        if (act === lastChar || this.isOperatorExpr(expressions[expressions.length - 1])) {\n                            state = -1; // invalid to end with an operator, or have 2 operators in conjunction\n                            break;\n                        } else {\n                            expressions.push(Expression.createOperatorExpression(char));\n                            state = 0;\n                        }\n                    } else if (char === '(') {\n                        // left parenthes found, seems to be the beginning of a new sub-expression:\n                        state = 'within-parentheses';\n                        tmp = '';\n                        pCount = 0;\n                    } else if (char === '[') {\n                        // left named var separator char found, seems to be the beginning of a named var:\n                        state = 'within-named-var';\n                        tmp = '';\n                    } else if (char.match(/[a-zA-Z]/)) {\n                        // multiple chars means it may be a function, else its a var which counts as own expression:\n                        if (act < lastChar && str.charAt(act + 1).match(/[a-zA-Z0-9_]/)) {\n                            tmp = char;\n                            state = 'within-func';\n                        } else {\n                            // Single variable found:\n                            // We need to check some special considerations:\n                            // - If the last char was a number (e.g. 3x), we need to create a multiplication out of it (3*x)\n                            if (\n                                expressions.length > 0 &&\n                                expressions[expressions.length - 1] instanceof ValueExpression\n                            ) {\n                                expressions.push(Expression.createOperatorExpression('*'));\n                            }\n                            expressions.push(new VariableExpression(char));\n                            this.registerVariable(char);\n                            state = 0;\n                            tmp = '';\n                        }\n                    }\n                    break;\n                case 'within-nr':\n                    char = str.charAt(act);\n                    if (char.match(/[0-9.]/)) {\n                        //Still within number, store and continue\n                        tmp += char;\n                        if (act === lastChar) {\n                            expressions.push(new ValueExpression(tmp));\n                            state = 0;\n                        }\n                    } else {\n                        // Number finished on last round, so add as expression:\n                        if (tmp === '-') {\n                            // just a single '-' means: a variable could follow (e.g. like in 3*-x), we convert it to -1: (3*-1x)\n                            tmp = -1;\n                        }\n                        expressions.push(new ValueExpression(tmp));\n                        tmp = '';\n                        state = 0;\n                        act--;\n                    }\n                    break;\n\n                case 'within-func':\n                    char = str.charAt(act);\n                    if (char.match(/[a-zA-Z0-9_]/)) {\n                        tmp += char;\n                    } else if (char === '(') {\n                        funcName = tmp;\n                        tmp = '';\n                        pCount = 0;\n                        state = 'within-func-parentheses';\n                    } else {\n                        throw new Error('Wrong character for function at position ' + act);\n                    }\n\n                    break;\n\n                case 'within-named-var':\n                    char = str.charAt(act);\n                    if (char === ']') {\n                        // end of named var, create expression:\n                        expressions.push(new VariableExpression(tmp));\n                        this.registerVariable(tmp);\n                        tmp = '';\n                        state = 0;\n                    } else if (char.match(/[a-zA-Z0-9_.]/)) {\n                        tmp += char;\n                    } else {\n                        throw new Error('Character not allowed within named variable: ' + char);\n                    }\n                    break;\n\n                case 'within-parentheses':\n                case 'within-func-parentheses':\n                    char = str.charAt(act);\n                    if (char === ')') {\n                        //Check if this is the matching closing parenthesis.If not, just read ahead.\n                        if (pCount <= 0) {\n                            // Yes, we found the closing parenthesis, create new sub-expression:\n                            if (state === 'within-parentheses') {\n                                expressions.push(new BracketExpression(this._do_parse(tmp)));\n                            } else if (state === 'within-func-parentheses') {\n                                // Function found: create expressions from the inner argument\n                                // string, and create a function expression with it:\n                                let args = this.splitFunctionParams(tmp).map((a) => this._do_parse(a));\n                                expressions.push(new FunctionExpression(funcName, args, this));\n                                funcName = null;\n                            }\n                            state = 0;\n                        } else {\n                            pCount--;\n                            tmp += char;\n                        }\n                    } else if (char === '(') {\n                        // begin of a new sub-parenthesis, increase counter:\n                        pCount++;\n                        tmp += char;\n                    } else {\n                        // all other things are just added to the sub-expression:\n                        tmp += char;\n                    }\n                    break;\n            }\n            act++;\n        }\n\n        if (state !== 0) {\n            throw new Error('Could not parse formula: Syntax error.');\n        }\n\n        return this.buildExpressionTree(expressions);\n    }\n\n    /**\n     * @see parse(): Builds an expression tree from the given expression array.\n     * Builds a tree with a single root expression in the correct order of operator precedence.\n     *\n     * Note that the given expression objects are modified and linked.\n     *\n     * @param {*} expressions\n     * @return {Expression} The root Expression of the built expression tree\n     */\n    buildExpressionTree(expressions) {\n        if (expressions.length < 1) {\n            return null;\n        }\n        const exprCopy = [...expressions];\n        let idx = 0;\n        let expr = null;\n        // Replace all Power expressions with a partial tree:\n        while (idx < exprCopy.length) {\n            expr = exprCopy[idx];\n            if (expr instanceof PowerExpression) {\n                if (idx === 0 || idx === exprCopy.length - 1) {\n                    throw new Error('Wrong operator position!');\n                }\n                expr.base = exprCopy[idx - 1];\n                expr.exponent = exprCopy[idx + 1];\n                exprCopy[idx - 1] = expr;\n                exprCopy.splice(idx, 2);\n            } else {\n                idx++;\n            }\n        }\n\n        // Replace all Mult/Div expressions with a partial tree:\n        idx = 0;\n        expr = null;\n        while (idx < exprCopy.length) {\n            expr = exprCopy[idx];\n            if (expr instanceof MultDivExpression) {\n                if (idx === 0 || idx === exprCopy.length - 1) {\n                    throw new Error('Wrong operator position!');\n                }\n                expr.left = exprCopy[idx - 1];\n                expr.right = exprCopy[idx + 1];\n                exprCopy[idx - 1] = expr;\n                exprCopy.splice(idx, 2);\n            } else {\n                idx++;\n            }\n        }\n\n        // Replace all Plus/Minus expressions with a partial tree:\n        idx = 0;\n        expr = null;\n        while (idx < exprCopy.length) {\n            expr = exprCopy[idx];\n            if (expr instanceof PlusMinusExpression) {\n                if (idx === 0 || idx === exprCopy.length - 1) {\n                    throw new Error('Wrong operator position!');\n                }\n                expr.left = exprCopy[idx - 1];\n                expr.right = exprCopy[idx + 1];\n                exprCopy[idx - 1] = expr;\n                exprCopy.splice(idx, 2);\n            } else {\n                idx++;\n            }\n        }\n        if (exprCopy.length !== 1) {\n            throw new Error('Could not parse formula: incorrect syntax?');\n        }\n        return exprCopy[0];\n    }\n\n    isOperator(char) {\n        return typeof char === 'string' && char.match(/[+\\-*/^]/);\n    }\n\n    isOperatorExpr(expr) {\n        return (\n            expr instanceof PlusMinusExpression || expr instanceof MultDivExpression || expr instanceof PowerExpression\n        );\n    }\n\n    registerVariable(varName) {\n        if (this._variables.indexOf(varName) < 0) {\n            this._variables.push(varName);\n        }\n    }\n\n    getVariables() {\n        return this._variables;\n    }\n\n    /**\n     * Evaluates a Formula by delivering values for the Formula's variables.\n     * E.g. if the formula is '3*x^2 + 2*x + 4', you should call `evaulate` as follows:\n     *\n     * evaluate({x:2}) --> Result: 20\n     *\n     * @param {Object|Array} valueObj An object containing values for variables and (unknown) functions,\n     *   or an array of such objects: If an array is given, all objects are evaluated and the results\n     *   also returned as array.\n     * @return {Number|Array} The evaluated result, or an array with results\n     */\n    evaluate(valueObj) {\n        // resolve multiple value objects recursively:\n        if (valueObj instanceof Array) {\n            return valueObj.map((v) => this.evaluate(v));\n        }\n        let expr = this.getExpression();\n        if (!(expr instanceof Expression)) {\n            throw new Error('No expression set: Did you init the object with a Formula?');\n        }\n        if (this.options.memoization) {\n            let res = this.resultFromMemory(valueObj);\n            if (res !== null) {\n                return res;\n            } else {\n                res = expr.evaluate({ ...MATH_CONSTANTS, ...valueObj });\n                this.storeInMemory(valueObj, res);\n                return res;\n            }\n        }\n        return expr.evaluate({ ...MATH_CONSTANTS, ...valueObj });\n    }\n\n    hashValues(valueObj) {\n        return JSON.stringify(valueObj);\n    }\n\n    resultFromMemory(valueObj) {\n        let key = this.hashValues(valueObj);\n        let res = this._memory[key];\n        if (res !== undefined) {\n            return res;\n        } else {\n            return null;\n        }\n    }\n\n    storeInMemory(valueObj, value) {\n        this._memory[this.hashValues(valueObj)] = value;\n    }\n\n    getExpression() {\n        return this.formulaExpression;\n    }\n\n    getExpressionString() {\n        return this.formulaExpression ? this.formulaExpression.toString() : '';\n    }\n\n    static calc(formula, valueObj, options = {}) {\n        valueObj = valueObj || {};\n        return new Formula(formula, options).evaluate(valueObj);\n    }\n}\n\nclass Expression {\n    static createOperatorExpression(operator, left = null, right = null) {\n        if (operator === '^') {\n            return new PowerExpression(operator, left, right);\n        }\n        if (operator === '*' || operator === '/') {\n            return new MultDivExpression(operator, left, right);\n        }\n        if (operator === '+' || operator === '-') {\n            return new PlusMinusExpression(operator, left, right);\n        }\n        throw new Error(`Unknown operator: ${operator}`);\n    }\n\n    evaluate(params = {}) {\n        throw new Error('Must be defined in child classes');\n    }\n\n    toString() {\n        return '';\n    }\n}\n\nclass BracketExpression extends Expression {\n    constructor(expr) {\n        super();\n        this.innerExpression = expr;\n        if (!(this.innerExpression instanceof Expression)) {\n            throw new Error('No inner expression given for bracket expression');\n        }\n    }\n    evaluate(params = {}) {\n        return this.innerExpression.evaluate(params);\n    }\n    toString() {\n        return `(${this.innerExpression.toString()})`;\n    }\n}\n\nclass ValueExpression extends Expression {\n    constructor(value) {\n        super();\n        this.value = Number(value);\n        if (isNaN(this.value)) {\n            throw new Error('Cannot parse number: ' + value);\n        }\n    }\n    evaluate(params = {}) {\n        return this.value;\n    }\n    toString() {\n        return String(this.value);\n    }\n}\n\nclass PlusMinusExpression extends Expression {\n    constructor(operator, left = null, right = null) {\n        super();\n        if (!['+', '-'].includes(operator)) {\n            throw new Error(`Operator not allowed in Plus/Minus expression: ${operator}`);\n        }\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n\n    evaluate(params = {}) {\n        if (this.operator === '+') {\n            return this.left.evaluate(params) + this.right.evaluate(params);\n        }\n        if (this.operator === '-') {\n            return this.left.evaluate(params) - this.right.evaluate(params);\n        }\n        throw new Error('Unknown operator for PlusMinus expression');\n    }\n\n    toString() {\n        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;\n    }\n}\n\nclass MultDivExpression extends Expression {\n    constructor(operator, left = null, right = null) {\n        super();\n        if (!['*', '/'].includes(operator)) {\n            throw new Error(`Operator not allowed in Multiply/Division expression: ${operator}`);\n        }\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n\n    evaluate(params = {}) {\n        if (this.operator === '*') {\n            return this.left.evaluate(params) * this.right.evaluate(params);\n        }\n        if (this.operator === '/') {\n            return this.left.evaluate(params) / this.right.evaluate(params);\n        }\n        throw new Error('Unknown operator for MultDiv expression');\n    }\n\n    toString() {\n        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;\n    }\n}\n\nclass PowerExpression extends Expression {\n    constructor(base = null, exponent = null) {\n        super();\n        this.base = base;\n        this.exponent = exponent;\n    }\n\n    evaluate(params = {}) {\n        return Math.pow(this.base.evaluate(params), this.exponent.evaluate(params));\n    }\n\n    toString() {\n        return `${this.base.toString()}^${this.exponent.toString()}`;\n    }\n}\nclass FunctionExpression extends Expression {\n    constructor(fn, argumentExpressions, formulaObject = null) {\n        super();\n        this.fn = fn;\n        this.argumentExpressions = argumentExpressions || [];\n        this.formulaObject = formulaObject;\n        this.blacklisted = undefined;\n    }\n\n    evaluate(params = {}) {\n        params = params || {};\n        const paramValues = this.argumentExpressions.map((a) => a.evaluate(params));\n\n        // If the params object itself has a function definition with\n        // the function name, call this one:\n        if (params[this.fn] instanceof Function) {\n            return params[this.fn].apply(this, paramValues);\n        }\n        // perhaps the Formula object has the function? so call it:\n        else if (this.formulaObject && this.formulaObject[this.fn] instanceof Function) {\n            // Don't, if it is blacklisted:\n            if (this.isBlacklisted()) {\n                throw new Error('Blacklisted function called: ' + this.fn);\n            }\n            return this.formulaObject[this.fn].apply(this.formulaObject, paramValues);\n        }\n        // Has the JS Math object a function as requested? Call it:\n        else if (Math[this.fn] instanceof Function) {\n            return Math[this.fn].apply(this, paramValues);\n        }\n        // No more options left: sorry!\n        else {\n            throw new Error('Function not found: ' + this.fn);\n        }\n    }\n\n    toString() {\n        return `${this.fn}(${this.argumentExpressions.map((a) => a.toString()).join(', ')})`;\n    }\n\n    isBlacklisted() {\n        // cache evaluation of blacklisted function, to save call time:\n        if (this.blacklisted === undefined) {\n            this.blacklisted = Formula.functionBlacklist.includes(\n                this.formulaObject ? this.formulaObject[this.fn] : null\n            );\n        }\n        return this.blacklisted;\n    }\n}\n\nfunction getProperty(object, path, fullPath) {\n    let curr = object;\n    for (let i = 0; i < path.length; i++) {\n        if (curr[path[i]] === undefined) {\n            throw new Error(`Cannot evaluate ${path[i]}, property not found (from path ${fullPath})`);\n        }\n\n        curr = curr[path[i]];\n    }\n\n    if (typeof curr === 'object') {\n        throw new Error('Invalid value');\n    }\n\n    return curr;\n}\n\nclass VariableExpression extends Expression {\n    constructor(fullPath) {\n        super();\n        this.fullPath = fullPath;\n        this.varPath = fullPath.split('.');\n    }\n\n    evaluate(params = {}) {\n        // params contain variable / value pairs: If this object's variable matches\n        // a varname found in the params, return the value.\n        // eg: params = {x: 5,y:3}, varname = x, return 5\n        // Objects and arrays are also supported:\n        // e.g. params = {x: {y: 5}}, varname = x.y, return 5\n        //  or  params = {x: [2,4,6]}, varname = x.2, return 6\n        return Number(getProperty(params, this.varPath, this.fullPath));\n    }\n    toString() {\n        return `${this.varPath.join('.')}`;\n    }\n}\n\nFormula.Expression = Expression;\nFormula.BracketExpression = BracketExpression;\nFormula.PowerExpression = PowerExpression;\nFormula.MultDivExpression = MultDivExpression;\nFormula.PlusMinusExpression = PlusMinusExpression;\nFormula.ValueExpression = ValueExpression;\nFormula.VariableExpression = VariableExpression;\nFormula.FunctionExpression = FunctionExpression;\nFormula.MATH_CONSTANTS = MATH_CONSTANTS;\n\n// Create a function blacklist:\nFormula.functionBlacklist = Object.getOwnPropertyNames(Formula.prototype)\n    .filter((prop) => Formula.prototype[prop] instanceof Function)\n    .map((prop) => Formula.prototype[prop]);\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/fparser.js\");\n",""],"names":["MATH_CONSTANTS","PI","Math","E","LN2","LN10","LOG2E","LOG10E","SQRT1_2","SQRT2","Formula","_exports","default","fStr","options","arguments","length","undefined","_classCallCheck","formulaExpression","_objectSpread","memoization","_variables","_memory","setFormula","_createClass","key","value","formulaString","formulaStr","parse","enableMemoization","disableMemoization","splitFunctionParams","toSplit","pCount","paramStr","params","_iterator","_createForOfIteratorHelper","split","_step","s","n","done","chr","push","Error","err","e","f","cleanupInputString","replace","Object","keys","forEach","c","RegExp","concat","str","_do_parse","_this","lastChar","act","state","expressions","char","tmp","funcName","charAt","match","isOperator","isOperatorExpr","Expression","createOperatorExpression","ValueExpression","VariableExpression","registerVariable","BracketExpression","args","map","a","FunctionExpression","buildExpressionTree","exprCopy","_toConsumableArray","idx","expr","PowerExpression","base","exponent","splice","MultDivExpression","left","right","PlusMinusExpression","varName","indexOf","getVariables","evaluate","valueObj","_this2","Array","v","getExpression","res","resultFromMemory","storeInMemory","hashValues","JSON","stringify","getExpressionString","toString","calc","formula","operator","_Expression","_inherits","_super","_createSuper","_this3","call","innerExpression","_Expression2","_super2","_this4","Number","isNaN","String","_Expression3","_super3","_this5","includes","_Expression4","_super4","_this6","_Expression5","_super5","_this7","pow","_Expression6","_super6","fn","argumentExpressions","_this8","formulaObject","blacklisted","paramValues","Function","apply","isBlacklisted","join","functionBlacklist","getProperty","object","path","fullPath","curr","i","_typeof","_Expression7","_super7","_this9","varPath","getOwnPropertyNames","prototype","filter","prop","module","exports"],"sourceRoot":""}